// Lecture 4 April 2018 - Databases

/*

Data - you have to store it before you can do anything with it.

Retreiving Data from a Database... We often do it in the form of a question.

"Where is the nearest car driver?"

"Which are the most popular movies?"

"What notifications do I have?"


Database: an organized way to store and retrieve data.



Relational Databases

Tables


Every row HAS to have a value for each column, even if it is null

Schema
id INTEGER PRIMARY KEY,
name TEXT,
age INTEGER,
country TEXT


Primary key - a unique identifier for the row.

If your database will generate an id for you, just rely on the fact that it's unique, and not any particular order.

You should have a primary key on every table you make. Generate them your own, don't rely on others. You can store
things that have been generated by others (facebook id for example) but don't use them as the primary key.


INTEGER
REAL
DECIMAL (scale, precision) 
TEXT  (VARCHAR - specifies text with a limit of the number you can store.)
BLOB (Way of telling database that you have bits you want to store, and the database will give them back to you.)

Decimal is a number that lets you store user-specified precision.
(Scale:)
(Precision: number of digits on the right side of the decimal)

If you don't care about precision, you can use a real number - because they're smaller (take up less space than decimals)


Blob - raw bits that the database doesn't know how to use. Just know that database won't be able to do anything with it.


SQL - Structured Query Language
'Sequel'

Way of talking to our database that isn't ambiguous. It's well-defined.


SQL is capable of full CRUD:

Create tables and rows

Read data out of tables

Update existing data

Delete data from tables




SQL - One language, any* relational database.


SQL Server (From Microsoft: .net or C# work)

Oracle (Too much money and don't know what to do with it? Oracle... very expensive)

MySQL (Most popular database used on the internet... Free and open source! Just download and run it. Wordpress...)
It used to be owned by Sun MicroSystems... Vertica (variant of MySQL)
(Loose and fast... But more strict nowadays)

SQLite (Most-used in general. A database designed to be run embedded. iOS and Android both use for backend/persistent storage...)

PostgreSQL
('Post-gress') (Was slow and strict... But a bit faster nowadays. Supports JSON as a column type.)
(You can store JSON, and then pull parts of it...)

*dialects vary.


Chinook - only stores data untill you refresh


Today, we'll make a database with a single table for storing injuries
Injury - something that has a name, a description, and a time to heal.




Before anything else, we need to create a table to store information

CREATE TABLE injury (
  ID INTEGER PRIMARY KEY AUTOINCREMENT,
  Name TEXT,
  Description TEXT, 
  tth INTEGER,
)

get information by typing select * (splat) 

The order you slect in (in the database) will determine how it's displayed to you

Modify your request: select upper(name) from injuries - will give you the results in uppercase

aggregate function: 

select min(tth) from injuries
(will produce one value from the row and produce the minimum value)

Don't rely on using min. The way to go in order to find out which rows have the minimum time to heal is to do a subquery

RUle of thumb: any time you do aggregate function: (avg, min, or max), only select other aggregates as well.

select tth, avg(tth) from injuries

Give your columns descriptive names... So when others look at your code, they'll be able to decipher what you're storing


select name, tth * 7 as "days to heal" from injuries

You can use double quotes to refer to a column.

Refer to text or a string, use single quotes



how many rows do we have?

select count(*) from injuries

----- will give us the number of rows

Primary keys have no other meaning besides that they represent the row.


If you care about the number of rows in a specific column, count will let you do that.


Generate an ID in SQLite:

insert into injuries(name, description, tth)
values('headache', 'pain in head', 1)

But don't rely on the order, since auto incrementing might not work how we want



When you want to select a single row:

select * from injuries
where id = 6

DELETE
delete from injuries where name = 'headache'


In SQL, = is not assignment, it is a mathmatecal equals

'' for string literals, "" is for column names

Case matters
BUT, you can use like instead of = and it won't worry about case sensitivity


% sign equals wildcard

select * from injuries 
where name like 'pulled%'

anything after the % is a wildcard


select * from injuries
where name like '%a%'

(show me all injuries that have an 'a' inside)


select * from injuries
where tth != 1


You can combine queries:

select * from injuries
where tth > 5 and name like '%d%'

(where time to heal is greater than 5, and name includes the letter 'd' )

you can also use 'or' for multiple 




If you have a list of ids you need to know about: 

select * from injuries
where id in (1, 2, 3, 7)



Let's say we want to change the order:

select * from injuries
order by tth

(order smallest to largest, but you can add 'desc' to change to from largest to smallest 'descending')


Add multiple criteria to order by: 

select * from injuries
order by tth, name

(orders by time to heal first, then alphabetically by name)


If you want to limit the number of rows that comes back, use the limit keyword:

select * from injuries
order by tth, name
limit 2

You will get two rows back.


"Show me the first 20 items ..."

// OFFSET, will let you skip a certain number. Below, it will show two rows at a time, but offset/skip the first four.

select * from injuries
order by tth, name
limit 2
offset 4


To get rid of duplicates from our results:
use the distinct keyword:

select distinct tth from injuries

(Distinct applies to all columns that are selected.)


If you want a random result, there is a function called random:

select * from injuries
order by random()
limit 1;

Will randomly order the results and only show one.

SQL Bolt, asks real-world questions you may be asked by your boss...


Search between two values:

SELECT * FROM movies
where Year between 2000 and 2010;



SELECT * FROM movies
order by Year
limit 5


SELECT * FROM movies
where Title like 'toy story%';

_ is like % (but only for single characters)

Where must come before order by

-- will comment out code in SQL


A Sub-Query: 

SELECT * FROM north_american_cities
where longitude < (select Longitude from north_american_cities
where city = 'Chicago')
order by longitude

Hard-coding values is not good, because you may want to change your search parameters



JOIN

Important, because in relational databases, there are multiple tables. JOIN lets you combine tables for the query


Select and join don't change the underlying data, it's just for the query.


SELECT * FROM Album
JOIN Artist
ON Album.ArtistId = Artist.ArtistId


SELECT * FROM movies
JOIN boxoffice on movies.id = boxoffice.movie_id

This allows us to put things back together for a query. Gives us access to both of the tables.

==============================================================
The thing you want to join on will usually be the Primary Key.
==============================================================

SELECT title, domestic_sales, international_sales
FROM movies
JOIN boxoffice on movies.id = boxoffice.movie_id
where international_sales > domestic_sales


Outer joins are less-common than inner


You have to have distinct apply to all columns, not just one

SELECT distinct building_name, role FROM buildings
left outer JOIN employees on buildings.building_name = employees.building;


Building is to the left of employees... So left join.

With a regular join, it will remove results that don't have a match.


With a left  OUTER join, all results will be displayed even if there isn't a match.
-Note- not always common... 


Null - 
In SQL, null has no equality semantics, so it's not equal to null.

Either is null, or is not null.


--DOES NOT WORK--
select * from injuries
where description = null

--WORKS--
select * from injuries
where description is null


SELECT * FROM buildings
left JOIN employees on buildings.building_name = employees.building
where name is null

This joins the buildings and employees tables, and then looks up which pieces of information are null.
you could also put "where role is null" or "where building is null"



*/
